package plugin

import (
	"context"

	"github.com/hashicorp/enos-provider/internal/server/resourcerouter"
	"github.com/hashicorp/terraform-plugin-go/tfprotov5"
	"github.com/hashicorp/terraform-plugin-go/tfprotov5/tftypes"
)

type {{.Struct}} struct{}

var _ resourcerouter.Resource = (*{{.Struct}})(nil)

type {{.State}} struct {
	ID        string
	Transport *embeddedTransportV1
}

var _ State = (*{{.State}})(nil)

func new{{.StructCap}}() *{{.Struct}} {
	return &{{.Struct}}{}
}

func new{{.StateCap}}() *{{.State}} {
	return &{{.State}}{
		Transport: newEmbeddedTransport(),
	}
}

func (r *{{.Struct}}) Name() string {
	return "{{.Name}}"
}

func (r *{{.Struct}}) Schema() *tfprotov5.Schema {
	return new{{.StateCap}}().Schema()
}

// ValidateResourceTypeConfig is the request Terraform sends when it wants to
// validate the resource's configuration.
func (r *{{.Struct}}) ValidateResourceTypeConfig(ctx context.Context, req *tfprotov5.ValidateResourceTypeConfigRequest) (*tfprotov5.ValidateResourceTypeConfigResponse, error) {
	res := &tfprotov5.ValidateResourceTypeConfigResponse{
		Diagnostics: []*tfprotov5.Diagnostic{},
	}

	select {
	case <-ctx.Done():
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(ctx.Err()))
		return res, ctx.Err()
	default:
	}

	newState := new{{.StateCap}}()
	err := unmarshal(newState, req.Config)
	if err != nil {
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(err))
		return res, err
	}

	return res, err
}

// ValidateResourceTypeConfig is the request Terraform sends when it wants to
// upgrade the resource's state to a new version.
//
// Upgrading the resource state generally goes as follows:
//
//   1. Unmarshal the RawState to the corresponding tftypes.Value that matches
//     schema version of the state we're upgrading from.
//   2. Create a new tftypes.Value for the current state and migrate the old
//    values to the new values.
//   3. Upgrade the existing state with the new values and return the marshaled
//    version of the current upgraded state.
//
func (r *{{.Struct}}) UpgradeResourceState(ctx context.Context, req *tfprotov5.UpgradeResourceStateRequest) (*tfprotov5.UpgradeResourceStateResponse, error) {
	res := &tfprotov5.UpgradeResourceStateResponse{
		Diagnostics: []*tfprotov5.Diagnostic{},
	}

	select {
	case <-ctx.Done():
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(ctx.Err()))
		return res, ctx.Err()
	default:
	}

	switch req.Version {
	case 1:
		// 1. unmarshal the raw state against the type that maps to the raw state
		// version. As this is version 1 and we're on version 1 we can use the
		// current state type.
		newState := new{{.StateCap}}()
		rawStateValues, err := req.RawState.Unmarshal(newState.Terraform5Type())
		if err != nil {
			res.Diagnostics = append(res.Diagnostics, errToDiagnostic(wrapErrWithDiagnostics(
				err,
				"upgrade error",
				"unable to map version 1 to the current state",
			)))
			return res, err
		}

		// 2. Since we're on version one we can pass the same values in without
		// doing a transform.

		// 3. Upgrade the current state with the new values, or in this case,
		// the raw values.
		res.UpgradedState, err = upgradeState(newState, rawStateValues)

		return res, err
	default:
		err := newErrWithDiagnostics(
			"Unexpected state version",
			"The provider doesn't know how to upgrade from the current state version",
		)
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(err))
		return res, err
	}
}

// ReadResource is the request Terraform sends when it wants to get the latest
// state for the resource.
func (r *{{.Struct}}) ReadResource(ctx context.Context, req *tfprotov5.ReadResourceRequest) (*tfprotov5.ReadResourceResponse, error) {
	res := &tfprotov5.ReadResourceResponse{
		Diagnostics: []*tfprotov5.Diagnostic{},
	}

	select {
	case <-ctx.Done():
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(ctx.Err()))
		return res, ctx.Err()
	default:
	}

	// unmarshal and re-marshal the state to add default fields
	newState := new{{.StateCap}}()
	err := unmarshal(newState, req.CurrentState)
	if err != nil {
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(err))
		return res, err
	}

	res.NewState, err = marshal(newState)
	if err != nil {
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(err))
		return res, err
	}

	return res, err
}

// PlanResourceChange is the request Terraform sends when it is generating a plan
// for the resource and wants the provider's input on what the planned state should be.
func (r *{{.Struct}}) PlanResourceChange(ctx context.Context, req *tfprotov5.PlanResourceChangeRequest) (*tfprotov5.PlanResourceChangeResponse, error) {
	res := &tfprotov5.PlanResourceChangeResponse{
		Diagnostics: []*tfprotov5.Diagnostic{},
	}

	select {
	case <-ctx.Done():
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(ctx.Err()))
		return res, ctx.Err()
	default:
	}

	priorState := new{{.StateCap}}()
	err := unmarshal(priorState, req.PriorState)
	if err != nil {
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(err))
		return res, err
	}

	proposedState := new{{.StateCap}}()
	err = unmarshal(proposedState, req.ProposedNewState)
	if err != nil {
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(err))
		return res, err
	}

	// Make sure that nothing in the transport requires replacing
	paths := transportReplacedAttributePaths(priorState.Transport, proposedState.Transport)
	if len(paths) > 0 {
		res.RequiresReplace = paths
	}

	// TODO: Update the plan if necessary. Make sure nothing in the proposed
	// state requires replacing.

	res.PlannedState, err = marshal(proposedState)
	if err != nil {
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(err))
		return res, err
	}

	return res, err
}

// ApplyResourceChange is the request Terraform sends when it needs to apply a
// planned set of changes to the resource.
func (r *{{.Struct}}) ApplyResourceChange(ctx context.Context, req *tfprotov5.ApplyResourceChangeRequest) (*tfprotov5.ApplyResourceChangeResponse, error) {
	res := &tfprotov5.ApplyResourceChangeResponse{
		Diagnostics: []*tfprotov5.Diagnostic{},
	}

	addDiagnostic := func(res *tfprotov5.ApplyResourceChangeResponse, err error) (*tfprotov5.ApplyResourceChangeResponse, error) {
		if err != nil {
			res.Diagnostics = append(res.Diagnostics, errToDiagnostic(err))
		}

		return res, err
	}

	select {
	case <-ctx.Done():
		return addDiagnostic(res, ctx.Err())
	default:
	}

	plannedState := new{{.StateCap}}()
	err := unmarshal(plannedState, req.PlannedState)
	if err != nil {
		return addDiagnostic(res, err)
	}

	// TODO: Delete
	// Check if the planned state attributes are blank. If they are then you
	// should delete the resource.
	/*
		if plannedState.Something == "" {
			// Delete the resource
			res.NewState, err = marshalDelete(plannedState)

			return res, err
		}
	*/

	err = plannedState.Validate(ctx)
	if err != nil {
		return addDiagnostic(res, err)
	}

	// TODO: Get the planned state's ID
	plannedID := "something"
	plannedState.ID = plannedID

	priorState := new{{.StateCap}}()
	err = unmarshal(priorState, req.PriorState)
	if err != nil {
		return addDiagnostic(res, err)
	}

	// If our priorState ID is blank then we're creating the resource
	if priorState.ID == "" {
		// TODO: create the resource
	} else if priorState.ID != "" && priorState.ID != plannedID {
		// TODO: update the resource
	}

	res.NewState, err = marshal(plannedState)
	if err != nil {
		return addDiagnostic(res, err)
	}

	return res, err
}

// ImportResourceState is the request Terraform sends when it wants the provider
// to import one or more resources specified by an ID.
//
// Importing a file doesn't make a lot of sense but we have to support the
// function regardless. As our only interface is a string ID, supporting this
// without provider level transport configuration would be absurdly difficult.
// Until then this will simply be a no-op. If/When we implement that behavior
// we could probably create use an identier that combines the source and
// destination to import a file.
func (r *{{.Struct}}) ImportResourceState(ctx context.Context, req *tfprotov5.ImportResourceStateRequest) (*tfprotov5.ImportResourceStateResponse, error) {
	res := &tfprotov5.ImportResourceStateResponse{
		ImportedResources: []*tfprotov5.ImportedResource{},
		Diagnostics:       []*tfprotov5.Diagnostic{},
	}

	select {
	case <-ctx.Done():
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(ctx.Err()))
		return res, ctx.Err()
	default:
	}

	newState := new{{.StateCap}}()
	state, err := marshal(newState)
	if err != nil {
		res.Diagnostics = append(res.Diagnostics, errToDiagnostic(err))
		return res, err
	}
	res.ImportedResources = append(res.ImportedResources, &tfprotov5.ImportedResource{
		TypeName: req.TypeName,
		State:    state,
	})

	return res, err
}

// Schema is the file states Terraform schema.
func (s *{{.State}}) Schema() *tfprotov5.Schema {
	return &tfprotov5.Schema{
		Version: 1,
		Block: &tfprotov5.SchemaBlock{
			Attributes: []*tfprotov5.SchemaAttribute{
				// TODO: Add all state attributes
				{
					Name:     "id",
					Type:     tftypes.String,
					Computed: true,
				},
				s.Transport.SchemaAttributeTransport(),
			},
		},
	}
}

// Validate validates the configuration. This will validate the source file
// exists and that the transport configuration is valid.
func (s *{{.State}}) Validate(ctx context.Context) error {
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}

	// TODO: Validate each state attribute
	/*
		if s.Attribute == "" {
			return newErrWithDiagnostics("invalid configuration", "you must provide the attribute", "attribute")
		}
	*/

	return s.Transport.Validate(ctx)
}

// FromTerraform5Value is a callback to unmarshal from the tftypes.Vault with As().
func (s *{{.State}}) FromTerraform5Value(val tftypes.Value) error {
	// TODO: Add each state attribute
	vals, err := mapAttributesTo(val, map[string]interface{}{
		"id": &s.ID,
	})
	if err != nil {
		return err
	}

	if !vals["transport"].IsKnown() {
		return nil
	}

	return s.Transport.FromTerraform5Value(vals["transport"])
}

// Terraform5Type is the file state tftypes.Type.
func (s *{{.State}}) Terraform5Type() tftypes.Type {
	// TODO: Add each state attribute
	return tftypes.Object{AttributeTypes: map[string]tftypes.Type{
		"id":        tftypes.String,
		"transport": s.Transport.Terraform5Type(),
	}}
}

// Terraform5Type is the file state tftypes.Value.
func (s *{{.State}}) Terraform5Value() tftypes.Value {
	// TODO: Add each state attribute
	return tftypes.NewValue(s.Terraform5Type(), map[string]tftypes.Value{
		"id":        tfMarshalStringValue(s.ID),
		"transport": s.Transport.Terraform5Value(),
	})
}
